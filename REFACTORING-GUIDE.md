# Руководство по рефакторингу ITsimulator

## Что было сделано

В рамках рефакторинга проекта ITsimulator была полностью переработана архитектура приложения для улучшения его структуры, производительности и поддерживаемости. Ниже приведены основные изменения и рекомендации по дальнейшей работе с кодом.

### 1. Новая структура проекта

Созданы директории для четкого разделения компонентов по их назначению:

```
src/
├── assets/                  # Статические ресурсы
├── components/              # Компоненты React
│   ├── common/              # Общие переиспользуемые компоненты
│   ├── dashboard/           # Компоненты панели управления
│   ├── game/                # Компоненты игрового интерфейса
│   ├── market/              # Компоненты рынка
│   └── products/            # Компоненты управления продуктами
├── hooks/                   # Пользовательские React хуки
├── store/                   # Управление состоянием Zustand
│   ├── slices/              # Срезы (slices) для логики
│   └── index.js             # Объединение срезов
├── utils/                   # Утилиты и вспомогательные функции
├── constants/               # Константы и конфигурация
└── models/                  # Модели данных
```

### 2. Модульное управление состоянием

Монолитное хранилище Zustand разделено на отдельные срезы (slices):

- `gameStateSlice.js` - Основное состояние игры (запуск/пауза/скорость/время)
- `companySlice.js` - Управление компанией игрока
- `marketSlice.js` - Управление рынком и конкурентами
- `uiSlice.js` - Управление интерфейсом пользователя
- `tickSlice.js` - Логика игрового тика (шага игры)

Каждый срез отвечает за определенную часть логики, что упрощает поддержку и расширение функциональности.

### 3. Отделение логики от представления

- Бизнес-логика вынесена в модели (`models/`) и срезы хранилища
- Компоненты используют хук `useGameStore` для доступа к необходимым данным и функциям
- Добавлен хук `useGameTick` для упрощения работы с игровым циклом

### 4. Улучшение работы с констатами

Все игровые константы и настройки вынесены в отдельные файлы в директории `constants/`:

- Налоговые ставки
- Начальные параметры
- Стоимость ресурсов
- Бизнес-метрики
- Параметры рынка

Это упрощает балансировку игры и тестирование различных сценариев.

### 5. Компонентный подход

- Компоненты разделены на логические группы
- Добавлена система уведомлений
- Улучшена модульность и переиспользуемость

## Рекомендации по дальнейшему развитию

### 1. Добавление TypeScript

Для увеличения стабильности и читаемости кода рекомендуется добавить TypeScript:

```bash
npm install --save typescript @types/react @types/react-dom
```

Создать файл `tsconfig.json` и постепенно переводить файлы с `.js` на `.tsx`.

### 2. Тестирование

Добавить тесты для критически важных компонентов и логики:

```bash
npm install --save-dev jest @testing-library/react @testing-library/jest-dom
```

### 3. Оптимизация производительности

- Использовать React.memo для компонентов, которые часто перерисовываются
- Использовать useCallback и useMemo для стабилизации функций и вычисляемых значений
- Оптимизировать селекторы Zustand для предотвращения ненужных ререндеров

### 4. Локализация

Для поддержки нескольких языков рекомендуется использовать библиотеку i18next:

```bash
npm install i18next react-i18next
```

### 5. Дополнительные возможности для рассмотрения

- Сохранение/загрузка игры (localStorage или сервер)
- Улучшенная статистика и графики
- Расширенная экономическая модель
- Система достижений
- Режим экспорта данных

## Переход на новую архитектуру

Для полного перехода на новую архитектуру необходимо:

1. Перевести оставшиеся компоненты в соответствующие директории
2. Обновить импорты во всех файлах
3. Убедиться, что все срезы хранилища корректно взаимодействуют друг с другом
4. Добавить дополнительные стили для новых компонентов (уведомления и т.д.)
5. Провести тестирование для выявления возможных ошибок

## Заключение

Рефакторинг существенно улучшил структуру проекта и создал прочную основу для дальнейшего развития. Новая архитектура позволяет легко добавлять новые функции и поддерживать существующий код.
